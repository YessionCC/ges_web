<!DOCTYPE html>
<html lang="en"> <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>GES Viewer (WebGL)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; touch-action: none; /* MODIFIED: Prevent default browser touch actions */ }
        
        /* MODIFIED: UI Container styling for collapsibility */
        #ui-container {
            position: absolute; top: 10px; left: 10px;
            display: flex; flex-direction: column; align-items: flex-start;
            pointer-events: none; z-index: 10;
        }

        #ui-toggle {
            pointer-events: auto; background: rgba(0,0,0,0.7); color: white;
            border: 1px solid #555; padding: 8px 12px; border-radius: 4px;
            cursor: pointer; font-size: 18px; margin-bottom: 5px;
            backdrop-filter: blur(5px);
        }

        #ui {
            color: white;
            background: rgba(0,0,0,0.7); padding: 15px; border-radius: 8px;
            pointer-events: auto; user-select: none; min-width: 260px;
            backdrop-filter: blur(5px); box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: transform 0.3s ease, opacity 0.3s ease;
            transform-origin: top left;
        }
        
        #ui.collapsed {
            transform: scaleY(0); opacity: 0; height: 0; padding: 0; overflow: hidden;
        }

        #status { font-weight: bold; margin-bottom: 5px; color: #4fc3f7; }
        .info { font-size: 12px; color: #ccc; margin-top: 5px; line-height: 1.5; }
        #loading {
            display: none; position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); color: white; font-size: 18px;
            background: rgba(0,0,0,0.85); padding: 20px 40px; border-radius: 8px;
            text-align: center; box-shadow: 0 10px 25px rgba(0,0,0,0.5); z-index: 100;
        }
        .progress-bar {
            width: 200px; height: 4px; background: #333; margin: 10px auto 0;
            border-radius: 2px; overflow: hidden;
        }
        .progress-fill {
            height: 100%; background: #4fc3f7; width: 0%; transition: width 0.1s;
        }
        .control-group { margin-top: 10px; border-top: 1px solid #444; padding-top: 10px; }
        .btn-row { display: flex; gap: 5px; margin-bottom: 8px; }
        button { flex: 1; background: #333; color: white; border: 1px solid #555; padding: 4px; cursor: pointer; border-radius: 4px; }
        button:hover { background: #444; }
        button.active { background: #4fc3f7; color: #000; font-weight: bold; }
        .slider-row { display: flex; align-items: center; justify-content: space-between; font-size: 11px; margin-bottom: 4px; }
        input[type=range] { width: 120px; }
        
        /* MODIFIED: Select and File Input styles */
        select { width: 100%; background: #333; color: white; border: 1px solid #555; padding: 4px; border-radius: 4px; margin-top: 4px; }
        input[type="file"] { display: none; }
        .file-btn { display: block; width: 100%; text-align: center; background: #444; padding: 6px 0; border-radius: 4px; cursor: pointer; border: 1px solid #555; margin-bottom: 5px; }
        .file-btn:hover { background: #555; }
    </style>
</head>
<body>
    <div id="ui-container">
        <button id="ui-toggle" onclick="toggleUI()">☰</button>
        <div id="ui">
            <h3 style="margin: 0 0 10px 0;">GES Viewer</h3>
            <div id="status">Ready. Please load a model.</div>
            <div class="info" id="stats"></div>
            
            <div class="control-group">
                <div style="font-size:12px; margin-bottom:4px; font-weight:bold;">Load Model</div>
                
                <label class="file-btn">
                    Open Local File (.ply)
                    <input type="file" id="file-input" accept=".ply" onchange="handleFileSelect(this)">
                </label>

                <select id="model-select" onchange="loadModelFromUrl(this.value)">
                    <option value="">-- Load Demo Model --</option>
                    <option value="https://huggingface.co/datasets/kyye/GES_simple_plys/resolve/main/lego.ply">lego.ply</option>
                    <option value="https://huggingface.co/datasets/kyye/GES_simple_plys/resolve/main/chair.ply">chair.ply</option>
                    <option value="https://huggingface.co/datasets/kyye/GES_simple_plys/resolve/main/garden3D.ply">garden.ply</option>
                    <option value="https://huggingface.co/datasets/kyye/GES_simple_plys/resolve/main/playroom.ply">playroom.ply</option>
                    </select>
            </div>

            <div class="control-group">
                <div style="font-size:12px; margin-bottom:4px; font-weight:bold;">Render Mode</div>
                <div class="btn-row">
                    <button id="btn-all" class="active" onclick="setRenderMode(0)">All</button>
                    <button id="btn-surfel" onclick="setRenderMode(1)">Surfels</button>
                    <button id="btn-gs" onclick="setRenderMode(2)">Gaussians</button>
                </div>
            </div>

            <div class="control-group">
                <div style="font-size:12px; margin-bottom:4px; font-weight:bold;">SH Degree</div>
                <div class="btn-row">
                    <button id="btn-sh0" class="active" onclick="setSHDegree(0)">0</button>
                    <button id="btn-sh1" onclick="setSHDegree(1)">1</button>
                    <button id="btn-sh2" onclick="setSHDegree(2)">2</button>
                    <button id="btn-sh3" onclick="setSHDegree(3)">3</button>
                </div>
            </div>

            <div class="control-group">
                <div style="font-size:12px; margin-bottom:4px; font-weight:bold;">Camera Params</div>
                <div class="slider-row">
                    <span>FOV (<span id="val-fov">45</span>°)</span>
                    <input type="range" min="10" max="120" value="45" oninput="updateCamParams('fov', this.value)">
                </div>
                <div class="slider-row">
                    <span>Near (<span id="val-near">0.1</span>)</span>
                    <input type="range" min="0.01" max="5.0" step="0.01" value="0.1" oninput="updateCamParams('near', this.value)">
                </div>
                <div class="slider-row">
                    <span>Far (<span id="val-far">1000</span>)</span>
                    <input type="range" min="100" max="5000" step="100" value="1000" oninput="updateCamParams('far', this.value)">
                </div>
            </div>

            <div class="info" style="margin-top:10px; border-top:1px solid #444; padding-top:5px;">
                <b>Controls:</b><br>
                PC: LMB Rotate, MMB Pan, Wheel Zoom<br>
                Mobile: 1 Finger Rotate, 2 Pan/Zoom
            </div>
        </div>
    </div>
    
    <div id="loading">
        <div id="loading-text">Processing...</div>
        <div class="progress-bar"><div class="progress-fill" id="progress"></div></div>
    </div>

    <canvas id="glcanvas"></canvas>

<script>
// ====================================================================================
// Shader Sources (Unchanged)
// ====================================================================================

const vsSurfelSource = `#version 300 es
precision highp float;
layout(location = 0) in vec3 center;
layout(location = 1) in vec4 color; // DC
layout(location = 2) in vec3 u_axis;
layout(location = 3) in vec3 v_axis;
layout(location = 4) in vec2 a_quad;
uniform mat4 viewMat;
uniform mat4 projMat;

uniform sampler2D texSH; 
uniform vec2 texSHDim; 
uniform int shDegree;
uniform vec3 camPos;

out vec4 v_color;
out vec2 v_uv;

const float SH_C1 = 0.4886025119029199;
const float SH_C2_0 = 1.0925484305920792;
const float SH_C2_1 = -1.0925484305920792;
const float SH_C2_2 = 0.31539156525252005;
const float SH_C2_3 = -1.0925484305920792;
const float SH_C2_4 = 0.5462742152960396;
const float SH_C3_0 = -0.5900435899266435;
const float SH_C3_1 = 2.890611442640554;
const float SH_C3_2 = -0.4570457994644658;
const float SH_C3_3 = 0.3731763325901154;
const float SH_C3_4 = -0.4570457994644658;
const float SH_C3_5 = 1.445305721320277;
const float SH_C3_6 = -0.5900435899266435;

vec3 computeSH(int idx, vec3 pos) {
    vec3 dir = normalize(pos - camPos);
    vec3 result = color.rgb - 0.5; // DC

    if (shDegree > 0) {
        int width = int(texSHDim.x);
        int baseIdx = idx * 12; 
        
        float x = dir.x; float y = dir.y; float z = dir.z;
        float xx = x*x; float yy = y*y; float zz = z*z;
        float xy = x*y; float yz = y*z; float xz = x*z;

        float sh1 = SH_C1 * y;
        float sh2 = SH_C1 * z;
        float sh3 = SH_C1 * x;
        
        vec4 r0 = texelFetch(texSH, ivec2((baseIdx)%width, (baseIdx)/width), 0);
        vec4 r1 = texelFetch(texSH, ivec2((baseIdx+1)%width, (baseIdx+1)/width), 0);
        vec4 r2 = texelFetch(texSH, ivec2((baseIdx+2)%width, (baseIdx+2)/width), 0);
        vec4 r3 = texelFetch(texSH, ivec2((baseIdx+3)%width, (baseIdx+3)/width), 0);

        result.r += sh1 * r0.x + sh2 * r0.y + sh3 * r0.z;

        vec4 g1 = texelFetch(texSH, ivec2((baseIdx+4)%width, (baseIdx+4)/width), 0);
        vec4 g2 = texelFetch(texSH, ivec2((baseIdx+5)%width, (baseIdx+5)/width), 0);
        vec4 g3 = texelFetch(texSH, ivec2((baseIdx+6)%width, (baseIdx+6)/width), 0);
        vec4 g4 = texelFetch(texSH, ivec2((baseIdx+7)%width, (baseIdx+7)/width), 0);

        result.g += sh1 * r3.w + sh2 * g1.x + sh3 * g1.y;

        vec4 b0 = texelFetch(texSH, ivec2((baseIdx+7)%width, (baseIdx+7)/width), 0);
        vec4 b1 = texelFetch(texSH, ivec2((baseIdx+8)%width, (baseIdx+8)/width), 0);
        vec4 b2 = texelFetch(texSH, ivec2((baseIdx+9)%width, (baseIdx+9)/width), 0);
        vec4 b3 = texelFetch(texSH, ivec2((baseIdx+10)%width, (baseIdx+10)/width), 0);
        vec4 b4 = texelFetch(texSH, ivec2((baseIdx+11)%width, (baseIdx+11)/width), 0);

        result.b += sh1 * b0.z + sh2 * b0.w + sh3 * b1.x;

        if (shDegree > 1) {
            float sh4 = SH_C2_0 * xy;
            float sh5 = SH_C2_1 * yz;
            float sh6 = SH_C2_2 * (2.0 * zz - xx - yy);
            float sh7 = SH_C2_3 * xz;
            float sh8 = SH_C2_4 * (xx - yy);

            result.r += sh4 * r0.w + sh5 * r1.x + sh6 * r1.y + sh7 * r1.z + sh8 * r1.w;
            result.g += sh4 * g1.z + sh5 * g1.w + sh6 * g2.x + sh7 * g2.y + sh8 * g2.z;
            result.b += sh4 * b1.y + sh5 * b1.z + sh6 * b1.w + sh7 * b2.x + sh8 * b2.y;

            if (shDegree > 2) {
                float sh9 = SH_C3_0 * y * (3.0 * xx - yy);
                float sh10 = SH_C3_1 * xy * z;
                float sh11 = SH_C3_2 * y * (4.0 * zz - xx - yy);
                float sh12 = SH_C3_3 * z * (2.0 * zz - 3.0 * xx - 3.0 * yy);
                float sh13 = SH_C3_4 * x * (4.0 * zz - xx - yy);
                float sh14 = SH_C3_5 * z * (xx - yy);
                float sh15 = SH_C3_6 * x * (xx - 3.0 * yy);

                result.r += sh9 * r2.x + sh10 * r2.y + sh11 * r2.z + sh12 * r2.w + sh13 * r3.x + sh14 * r3.y + sh15 * r3.z;
                result.g += sh9 * g2.w + sh10 * g3.x + sh11 * g3.y + sh12 * g3.z + sh13 * g3.w + sh14 * g4.x + sh15 * g4.y;
                result.b += sh9 * b2.z + sh10 * b2.w + sh11 * b3.x + sh12 * b3.y + sh13 * b3.z + sh14 * b3.w + sh15 * b4.x;
            }
        }
    }
    return result + 0.5;
}

void main() {
    vec4 p_view = viewMat * vec4(center, 1.0);
    if (p_view.z > -0.2) { gl_Position = vec4(0,0,2,1); return; }
    float cutoff = 3.4; 
    vec3 offset = (u_axis * a_quad.x + v_axis * a_quad.y) * cutoff;
    vec4 view_pos = viewMat * vec4(center + offset, 1.0);
    gl_Position = projMat * view_pos;
    
    vec3 shColor = computeSH(gl_InstanceID, center);
    v_color = vec4(shColor, view_pos.z - color.a); 
    v_uv = a_quad * cutoff;
}`;

const fsSurfelSource = `#version 300 es
precision highp float;
in vec4 v_color;
in vec2 v_uv;
layout(location = 0) out vec4 out_color;
void main() {
    float logG = -0.5 * dot(v_uv, v_uv);
    if (logG < -5.54) discard; 
    out_color = v_color;
}`;

const vsGaussianSource = `#version 300 es
precision highp float;

layout(location = 0) in vec3 center;
layout(location = 1) in vec4 color; // DC
layout(location = 2) in vec3 cov3Da; 
layout(location = 3) in vec3 cov3Db; 
layout(location = 4) in vec3 cov3Dc; 
layout(location = 5) in vec2 a_quad; 

uniform mat4 viewMat;
uniform mat4 projMat;
uniform vec4 viewport;
uniform vec4 projParams; 

// SH Uniforms
uniform sampler2D texSH; 
uniform vec2 texSHDim; 
uniform int shDegree;
uniform vec3 camPos;

out vec4 v_color;
out vec4 v_cov2inv;
out vec2 v_screenPos;

// SH Constants
const float SH_C1 = 0.4886025119029199;
const float SH_C2_0 = 1.0925484305920792;
const float SH_C2_1 = -1.0925484305920792;
const float SH_C2_2 = 0.31539156525252005;
const float SH_C2_3 = -1.0925484305920792;
const float SH_C2_4 = 0.5462742152960396;
const float SH_C3_0 = -0.5900435899266435;
const float SH_C3_1 = 2.890611442640554;
const float SH_C3_2 = -0.4570457994644658;
const float SH_C3_3 = 0.3731763325901154;
const float SH_C3_4 = -0.4570457994644658;
const float SH_C3_5 = 1.445305721320277;
const float SH_C3_6 = -0.5900435899266435;

vec3 computeSH(int idx, vec3 pos) {
    vec3 dir = normalize(pos - camPos);
    vec3 result = color.rgb - 0.5; // DC

    if (shDegree > 0) {
        int width = int(texSHDim.x);
        int baseIdx = idx * 12; 
        
        float x = dir.x; float y = dir.y; float z = dir.z;
        float xx = x*x; float yy = y*y; float zz = z*z;
        float xy = x*y; float yz = y*z; float xz = x*z;

        float sh1 = SH_C1 * y;
        float sh2 = SH_C1 * z;
        float sh3 = SH_C1 * x;
        
        vec4 r0 = texelFetch(texSH, ivec2((baseIdx)%width, (baseIdx)/width), 0);
        vec4 r1 = texelFetch(texSH, ivec2((baseIdx+1)%width, (baseIdx+1)/width), 0);
        vec4 r2 = texelFetch(texSH, ivec2((baseIdx+2)%width, (baseIdx+2)/width), 0);
        vec4 r3 = texelFetch(texSH, ivec2((baseIdx+3)%width, (baseIdx+3)/width), 0);

        result.r += sh1 * r0.x + sh2 * r0.y + sh3 * r0.z;

        vec4 g1 = texelFetch(texSH, ivec2((baseIdx+4)%width, (baseIdx+4)/width), 0);
        vec4 g2 = texelFetch(texSH, ivec2((baseIdx+5)%width, (baseIdx+5)/width), 0);
        vec4 g3 = texelFetch(texSH, ivec2((baseIdx+6)%width, (baseIdx+6)/width), 0);
        vec4 g4 = texelFetch(texSH, ivec2((baseIdx+7)%width, (baseIdx+7)/width), 0);

        result.g += sh1 * r3.w + sh2 * g1.x + sh3 * g1.y;

        vec4 b0 = texelFetch(texSH, ivec2((baseIdx+7)%width, (baseIdx+7)/width), 0);
        vec4 b1 = texelFetch(texSH, ivec2((baseIdx+8)%width, (baseIdx+8)/width), 0);
        vec4 b2 = texelFetch(texSH, ivec2((baseIdx+9)%width, (baseIdx+9)/width), 0);
        vec4 b3 = texelFetch(texSH, ivec2((baseIdx+10)%width, (baseIdx+10)/width), 0);
        vec4 b4 = texelFetch(texSH, ivec2((baseIdx+11)%width, (baseIdx+11)/width), 0);

        result.b += sh1 * b0.z + sh2 * b0.w + sh3 * b1.x;

        if (shDegree > 1) {
            float sh4 = SH_C2_0 * xy;
            float sh5 = SH_C2_1 * yz;
            float sh6 = SH_C2_2 * (2.0 * zz - xx - yy);
            float sh7 = SH_C2_3 * xz;
            float sh8 = SH_C2_4 * (xx - yy);

            result.r += sh4 * r0.w + sh5 * r1.x + sh6 * r1.y + sh7 * r1.z + sh8 * r1.w;
            result.g += sh4 * g1.z + sh5 * g1.w + sh6 * g2.x + sh7 * g2.y + sh8 * g2.z;
            result.b += sh4 * b1.y + sh5 * b1.z + sh6 * b1.w + sh7 * b2.x + sh8 * b2.y;

            if (shDegree > 2) {
                float sh9 = SH_C3_0 * y * (3.0 * xx - yy);
                float sh10 = SH_C3_1 * xy * z;
                float sh11 = SH_C3_2 * y * (4.0 * zz - xx - yy);
                float sh12 = SH_C3_3 * z * (2.0 * zz - 3.0 * xx - 3.0 * yy);
                float sh13 = SH_C3_4 * x * (4.0 * zz - xx - yy);
                float sh14 = SH_C3_5 * z * (xx - yy);
                float sh15 = SH_C3_6 * x * (xx - 3.0 * yy);

                result.r += sh9 * r2.x + sh10 * r2.y + sh11 * r2.z + sh12 * r2.w + sh13 * r3.x + sh14 * r3.y + sh15 * r3.z;
                result.g += sh9 * g2.w + sh10 * g3.x + sh11 * g3.y + sh12 * g3.z + sh13 * g3.w + sh14 * g4.x + sh15 * g4.y;
                result.b += sh9 * b2.z + sh10 * b2.w + sh11 * b3.x + sh12 * b3.y + sh13 * b3.z + sh14 * b3.w + sh15 * b4.x;
            }
        }
    }
    return result + 0.5;
}

void main() {
    vec4 t = viewMat * vec4(center, 1.0);
    
    if (t.z > -0.2) { gl_Position = vec4(0,0,2,1); return; }

    float WIDTH = viewport.z;
    float HEIGHT = viewport.w;
    float Z_NEAR = projParams.y;
    float Z_FAR = projParams.z;

    float limx = 1.3 * (1.0 / projMat[0][0]);
    float limy = 1.3 * (1.0 / projMat[1][1]);
    
    float txtz = t.x / t.z;
    float tytz = t.y / t.z;
    
    t.x = min(limx, max(-limx, txtz)) * t.z;
    t.y = min(limy, max(-limy, tytz)) * t.z;

    float SX = projMat[0][0]; 
    float SY = projMat[1][1];
    float WZ = projMat[3][2];
    float tzSq = t.z * t.z;

    float jsx = -(SX * WIDTH) / (2.0 * t.z);
    float jsy = -(SY * HEIGHT) / (2.0 * t.z);
    float jtx = (SX * t.x * WIDTH) / (2.0 * tzSq);
    float jty = (SY * t.y * HEIGHT) / (2.0 * tzSq);
    float jtz = ((Z_FAR - Z_NEAR) * WZ) / (2.0 * tzSq);

    mat3 J = mat3(
        vec3(jsx, 0.0, 0.0),
        vec3(0.0, jsy, 0.0),
        vec3(jtx, jty, jtz)
    );

    mat3 W = mat3(viewMat);
    mat3 V = mat3(cov3Da, cov3Db, cov3Dc);
    mat3 JW = J * W;
    mat3 V_prime = JW * V * transpose(JW);
    
    mat2 cov2D = mat2(V_prime); 

    float kernel_size = 0.3; 
    cov2D[0][0] += kernel_size; 
    cov2D[1][1] += kernel_size;

    float a = cov2D[0][0];
    float b = cov2D[0][1];
    float c = cov2D[1][1];
    
    float det = a * c - b * b;
    if (det <= 0.0) { gl_Position = vec4(0,0,2,1); return; }

    float detInv = 1.0 / det;
    v_cov2inv = vec4(c * detInv, -b * detInv, -b * detInv, a * detInv);

    float trace = a + c;
    float term = sqrt(max(0.0, (a - c) * (a - c) + 4.0 * b * b));
    float lambda1 = (trace + term) / 2.0;
    float lambda2 = (trace - term) / 2.0;
    
    float radius = 3.4; 
    float r1 = radius * sqrt(lambda1);
    float r2 = radius * sqrt(lambda2);
    
    vec2 u_dir;
    if (b == 0.0) {
        u_dir = (a >= c) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    } else {
        u_dir = normalize(vec2(b, lambda1 - a));
    }
    vec2 v_dir = vec2(-u_dir.y, u_dir.x); 

    vec2 offsetScreen = (u_dir * r1 * a_quad.x) + (v_dir * r2 * a_quad.y);
    
    vec4 p_proj = projMat * viewMat * vec4(center, 1.0);; 
    
    vec2 offsetClip = (offsetScreen / vec2(WIDTH, HEIGHT)) * 2.0 * p_proj.w;
    
    gl_Position = p_proj + vec4(offsetClip, 0.0, 0.0);
    
    v_screenPos = (p_proj.xy / p_proj.w) * 0.5 + 0.5;
    v_screenPos *= vec2(WIDTH, HEIGHT);
    
    // Compute Color using SH
    v_color = vec4(computeSH(gl_InstanceID, center), color.a);
}`;

const fsGaussianSource = `#version 300 es
precision highp float;
in vec4 v_color;
in vec4 v_cov2inv;
in vec2 v_screenPos;
layout(location = 0) out vec4 out_color;

void main() {
    vec2 d = gl_FragCoord.xy - v_screenPos;
    mat2 covInv = mat2(v_cov2inv.xy, v_cov2inv.zw);
    
    float power = -0.5 * dot(d, covInv * d);
    if (power > 0.0) discard; 
    
    float g = exp(power);
    float alpha = v_color.a * g;
    
    if (alpha < 1.0/255.0) discard;
    
    out_color = vec4(v_color.rgb * alpha, alpha);
}`;

const vsQuadSource = `#version 300 es
layout(location = 0) in vec2 position;
out vec2 v_uv;
void main() {
    v_uv = position * 0.5 + 0.5;
    gl_Position = vec4(position, 0.0, 1.0);
}`;

const fsNormalizeSource = `#version 300 es
precision highp float;
in vec2 v_uv;
uniform sampler2D texColor;
out vec4 out_color;
void main() {
    vec4 accum = texture(texColor, v_uv);
    out_color = vec4(accum.rgb / (accum.a + 1.0), 1.0);
}`;

const fsDepthModSource = `#version 300 es
precision highp float;
in vec2 v_uv;
uniform sampler2D texColor;
uniform vec2 zNearFar;
out vec4 out_color;
float depthSample(float linearDepth) {
    float zNear = zNearFar.x; float zFar = zNearFar.y;
    float nonLinearDepth = (zFar + zNear - 2.0 * zNear * zFar / linearDepth) / (zFar - zNear);
    nonLinearDepth = (nonLinearDepth + 1.0) / 2.0;
    return nonLinearDepth;
}
void main() {
    vec4 color_depth = texture(texColor, v_uv);
    gl_FragDepth = depthSample(-color_depth.w);
    out_color = vec4(color_depth.rgb, 0.0);
}`;

// ====================================================================================
// WebGL Context
// ====================================================================================
const canvas = document.getElementById('glcanvas');
const gl = canvas.getContext('webgl2', { 
    antialias: false, 
    powerPreference: "high-performance",
    alpha: false,
    desynchronized: true
});
if (!gl) alert("WebGL2 not supported");
if (!gl.getExtension("EXT_color_buffer_float")) alert("Need EXT_color_buffer_float");

function createProgram(gl, vsSrc, fsSrc) {
    const vs = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vs, vsSrc); gl.compileShader(vs);
    if(!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(vs));
    const fs = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fs, fsSrc); gl.compileShader(fs);
    if(!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(fs));
    const p = gl.createProgram(); gl.attachShader(p, vs); gl.attachShader(p, fs); gl.linkProgram(p);
    return p;
}

const progSurfel = createProgram(gl, vsSurfelSource, fsSurfelSource);
const progGaussian = createProgram(gl, vsGaussianSource, fsGaussianSource);
const progNormalize = createProgram(gl, vsQuadSource, fsNormalizeSource);
const progDepthMod = createProgram(gl, vsQuadSource, fsDepthModSource);

const quadVBO = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quadVBO);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);

const vaoQuad = gl.createVertexArray();
gl.bindVertexArray(vaoQuad);
gl.bindBuffer(gl.ARRAY_BUFFER, quadVBO);
gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
gl.enableVertexAttribArray(0);
gl.bindVertexArray(null);

// ====================================================================================
// Framebuffer Setup
// ====================================================================================
let surfel_fbo = null;
let accum_fbo = null;

class FrameBufferObject {
    constructor(gl, width, height) {
        this.gl = gl;
        this.width = width;
        this.height = height;
        this.framebuffer = null;
        this.texture = null;
        this.depthBuffer = null;
        this.init();
    }

    init() {
        const gl = this.gl;
        this.dispose();

        this.framebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);

        this.texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA16F, this.width, this.height, 0, gl.RGBA, gl.FLOAT, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);

        this.depthBuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, this.depthBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.width, this.height);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.depthBuffer);

        const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        if (status !== gl.FRAMEBUFFER_COMPLETE) console.error('Framebuffer creation failed: ' + status);

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    }

    resize(width, height) {
        if (this.width === width && this.height === height) return;
        this.width = width;
        this.height = height;
        this.init(); 
    }

    bind() {
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.framebuffer);
        this.gl.viewport(0, 0, this.width, this.height);
    }

    unbind() {
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
    }

    getTexture() { return this.texture; }

    dispose() {
        const gl = this.gl;
        if (this.framebuffer) gl.deleteFramebuffer(this.framebuffer);
        if (this.texture) gl.deleteTexture(this.texture);
        if (this.depthBuffer) gl.deleteRenderbuffer(this.depthBuffer);
        this.framebuffer = null;
        this.texture = null;
        this.depthBuffer = null;
    }
}

window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    surfel_fbo.resize(canvas.width, canvas.height);
    accum_fbo.resize(canvas.width, canvas.height);
});

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
surfel_fbo = new FrameBufferObject(gl, canvas.width, canvas.height);
accum_fbo = new FrameBufferObject(gl, canvas.width, canvas.height);

// ====================================================================================
// PLY Parsing & Processing 
// ====================================================================================
async function loadPly(buffer) {
    const status = document.getElementById('loading-text'); // MODIFIED: Fixed incorrect ID reference in previous versions if any
    const progress = document.getElementById('progress');
    // MODIFIED: Ensure status element exists
    if(status) status.innerText = "Parsing Header...";

    const dec = new TextDecoder();
    const headerStr = dec.decode(buffer.slice(0, 2000));
    const headerEnd = headerStr.indexOf('end_header');
    if (headerEnd === -1) throw "Invalid PLY";
    
    const lines = headerStr.slice(0, headerEnd).split('\n');
    let vCount = 0, props = {}, offset = 0;
    
    for (let line of lines) {
        line = line.trim();
        if (line.startsWith('element vertex')) vCount = parseInt(line.split(' ')[2]);
        else if (line.startsWith('property float')) { props[line.split(' ')[2]] = offset; offset += 4; }
    }
    
    const dataStart = headerEnd + "end_header\n".length;
    const dataView = new DataView(buffer, dataStart);
    
    let surfelData = [];
    let gaussianData = [];
    let surfelSHData = [];
    let gaussianSHData = [];
    
    let sumX = 0, sumY = 0, sumZ = 0;
    let surfelNum = 0;

    if(status) status.innerText = "Classifying Data...";
    const chunkSize = 10000;

    for (let i = 0; i < vCount; i++) {
        if (i % chunkSize === 0) {
             progress.style.width = (i / vCount * 100) + "%";
             await new Promise(r => setTimeout(r, 0));
        }

        const base = i * offset;
        const rawOp = dataView.getFloat32(base + props['opacity'], true);

        let isSurfel = false;
        if (rawOp > 1000.0) isSurfel = true;
        
        const x = dataView.getFloat32(base + props['x'], true);
        const y = dataView.getFloat32(base + props['y'], true);
        const z = dataView.getFloat32(base + props['z'], true);
        
        const cr = 0.5 + 0.28209 * dataView.getFloat32(base + props['f_dc_0'], true);
        const cg = 0.5 + 0.28209 * dataView.getFloat32(base + props['f_dc_1'], true);
        const cb = 0.5 + 0.28209 * dataView.getFloat32(base + props['f_dc_2'], true);
        
        const s0 = Math.exp(dataView.getFloat32(base + props['scale_0'], true));
        const s1 = Math.exp(dataView.getFloat32(base + props['scale_1'], true));
        const s2 = isSurfel ? 0 : Math.exp(dataView.getFloat32(base + (props['scale_2']), true)); 

        let r0 = dataView.getFloat32(base + (props['rot_0']), true);
        let r1 = dataView.getFloat32(base + (props['rot_1']), true);
        let r2 = dataView.getFloat32(base + (props['rot_2']), true);
        let r3 = dataView.getFloat32(base + (props['rot_3']), true);
        const n = Math.sqrt(r0*r0+r1*r1+r2*r2+r3*r3);
        const invN = 1.0/n; r0*=invN; r1*=invN; r2*=invN; r3*=invN;

        const R = [
            1 - 2*(r2*r2 + r3*r3), 2*(r1*r2 - r0*r3), 2*(r1*r3 + r0*r2),
            2*(r1*r2 + r0*r3), 1 - 2*(r1*r1 + r3*r3), 2*(r2*r3 - r0*r1),
            2*(r1*r3 - r0*r2), 2*(r2*r3 + r0*r1), 1 - 2*(r1*r1 + r2*r2)
        ];

        let currentSH = [];
        if ('f_rest_0' in props) {
            for(let k=0; k<45; k++) {
                currentSH.push(dataView.getFloat32(base + props[`f_rest_${k}`], true));
            }
        } else {
            for(let k=0; k<45; k++) currentSH.push(0);
        }

        if (isSurfel) {
            const opVal = rawOp - 1000.0;
            surfelData.push(
                x, y, z, 
                Math.max(0,cr), Math.max(0,cg), Math.max(0,cb), opVal,
                R[0]*s0, R[3]*s0, R[6]*s0, 
                R[1]*s1, R[4]*s1, R[7]*s1 
            );
            surfelSHData.push(...currentSH);
            sumX += x; sumY += y; sumZ += z;
            surfelNum++;
        } 
        else {
            const opVal = rawOp;
            const m00 = R[0]*s0, m01 = R[1]*s1, m02 = R[2]*s2;
            const m10 = R[3]*s0, m11 = R[4]*s1, m12 = R[5]*s2;
            const m20 = R[6]*s0, m21 = R[7]*s1, m22 = R[8]*s2;
            
            const c00 = m00*m00 + m01*m01 + m02*m02;
            const c01 = m00*m10 + m01*m11 + m02*m12;
            const c02 = m00*m20 + m01*m21 + m02*m22;
            const c11 = m10*m10 + m11*m11 + m12*m12;
            const c12 = m10*m20 + m11*m21 + m12*m22;
            const c22 = m20*m20 + m21*m21 + m22*m22;

            gaussianData.push(
                x, y, z,
                Math.max(0,cr), Math.max(0,cg), Math.max(0,cb), opVal,
                c00, c01, c02, 
                c01, c11, c12, 
                c02, c12, c22  
            );
            gaussianSHData.push(...currentSH);
        }
    }
    
    if (surfelNum > 0) {
        const cx = sumX / surfelNum;
        const cy = sumY / surfelNum;
        const cz = sumZ / surfelNum;
        camera.target = [cx, cy, cz];
        camera.radius = 5.0; 
        camera.quat = Quat.identity();
    }

    return {
        surfelData: new Float32Array(surfelData),
        gaussianData: new Float32Array(gaussianData),
        surfelSHData: new Float32Array(surfelSHData),
        gaussianSHData: new Float32Array(gaussianSHData)
    };
}

// ====================================================================================
// Upload Data
// ====================================================================================
let vaoSurfel = null, vaoGaussian = null;
let countSurfel = 0, countGaussian = 0;
let texSHSurfel = null;
let texSHGaussian = null;
let texSHSurfelDim = [0, 0];
let texSHGaussianDim = [0, 0];

function createSHTexture(gl, shFloatArray, count) {
    if (!count || shFloatArray.length === 0) return { tex: null, dim: [0,0] };
    
    const floatsPerItem = 45;
    const pixelsPerItem = 12; // 48 floats capacity (RGBA32F)
    const width = 4096;
    const totalPixels = count * pixelsPerItem;
    const height = Math.ceil(totalPixels / width);
    
    const texData = new Float32Array(width * height * 4);
    
    for(let i=0; i<count; i++) {
        const srcBase = i * floatsPerItem;
        const dstBase = i * pixelsPerItem * 4;
        for(let k=0; k<floatsPerItem; k++) {
            texData[dstBase + k] = shFloatArray[srcBase + k];
        }
    }

    const tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, width, height, 0, gl.RGBA, gl.FLOAT, texData);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    
    return { tex: tex, dim: [width, height] };
}

function uploadData(data) {
    if (vaoSurfel) gl.deleteVertexArray(vaoSurfel);
    if (vaoGaussian) gl.deleteVertexArray(vaoGaussian);
    if (texSHSurfel) gl.deleteTexture(texSHSurfel);
    if (texSHGaussian) gl.deleteTexture(texSHGaussian);
    
    // Surfel
    if (data.surfelData.length > 0) {
        vaoSurfel = gl.createVertexArray();
        gl.bindVertexArray(vaoSurfel);
        const buf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buf);
        gl.bufferData(gl.ARRAY_BUFFER, data.surfelData, gl.STATIC_DRAW);
        
        const F = 4; 
        const S = 13 * F;
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, S, 0);       gl.enableVertexAttribArray(0); gl.vertexAttribDivisor(0, 1);
        gl.vertexAttribPointer(1, 4, gl.FLOAT, false, S, 3*F);     gl.enableVertexAttribArray(1); gl.vertexAttribDivisor(1, 1);
        gl.vertexAttribPointer(2, 3, gl.FLOAT, false, S, 7*F);     gl.enableVertexAttribArray(2); gl.vertexAttribDivisor(2, 1);
        gl.vertexAttribPointer(3, 3, gl.FLOAT, false, S, 10*F);    gl.enableVertexAttribArray(3); gl.vertexAttribDivisor(3, 1);
        
        gl.bindBuffer(gl.ARRAY_BUFFER, quadVBO);
        gl.vertexAttribPointer(4, 2, gl.FLOAT, false, 0, 0);       gl.enableVertexAttribArray(4); gl.vertexAttribDivisor(4, 0);
        
        countSurfel = data.surfelData.length / 13;

        const res = createSHTexture(gl, data.surfelSHData, countSurfel);
        texSHSurfel = res.tex;
        texSHSurfelDim = res.dim;
    }

    // Gaussian
    if (data.gaussianData.length > 0) {
        vaoGaussian = gl.createVertexArray();
        gl.bindVertexArray(vaoGaussian);
        const buf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buf);
        gl.bufferData(gl.ARRAY_BUFFER, data.gaussianData, gl.STATIC_DRAW);
        
        const F = 4; 
        const S = 16 * F;
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, S, 0);       gl.enableVertexAttribArray(0); gl.vertexAttribDivisor(0, 1);
        gl.vertexAttribPointer(1, 4, gl.FLOAT, false, S, 3*F);     gl.enableVertexAttribArray(1); gl.vertexAttribDivisor(1, 1);
        gl.vertexAttribPointer(2, 3, gl.FLOAT, false, S, 7*F);     gl.enableVertexAttribArray(2); gl.vertexAttribDivisor(2, 1);
        gl.vertexAttribPointer(3, 3, gl.FLOAT, false, S, 10*F);    gl.enableVertexAttribArray(3); gl.vertexAttribDivisor(3, 1);
        gl.vertexAttribPointer(4, 3, gl.FLOAT, false, S, 13*F);    gl.enableVertexAttribArray(4); gl.vertexAttribDivisor(4, 1);

        gl.bindBuffer(gl.ARRAY_BUFFER, quadVBO);
        gl.vertexAttribPointer(5, 2, gl.FLOAT, false, 0, 0);       gl.enableVertexAttribArray(5); gl.vertexAttribDivisor(5, 0);
        
        countGaussian = data.gaussianData.length / 16;

        const res = createSHTexture(gl, data.gaussianSHData, countGaussian);
        texSHGaussian = res.tex;
        texSHGaussianDim = res.dim;
    }
    
    gl.bindVertexArray(null);
    document.getElementById('stats').innerHTML = `Surf: ${countSurfel}, Gauss: ${countGaussian}`;
    const statusEl = document.getElementById('status');
    statusEl.innerText = "Model Loaded. (Drop/Select to replace)";
    statusEl.style.color = "#4fc3f7"; 
}

// ====================================================================================
// Math & Camera
// ====================================================================================
let camConfig = {
    fov: 45,
    near: 0.1,
    far: 1000.0
};

// MODIFIED: UI Helpers for Mobile and Model Loading
function toggleUI() {
    document.getElementById('ui').classList.toggle('collapsed');
}

function checkMobile() {
    // Basic mobile detection
    if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
        // Force Surfel Mode on mobile
        setRenderMode(1); 
        console.log("Mobile detected: Defaulting to Surfel Mode");
        // Collapsing UI by default on mobile
        document.getElementById('ui').classList.add('collapsed');
    }
}

// Load from File Input
function handleFileSelect(input) {
    const f = input.files[0];
    if(!f) return;
    document.getElementById('loading').style.display = 'block';
    document.getElementById('status').innerText = "Loading local file...";
    const r = new FileReader();
    r.onload = async(ev) => {
        try { uploadData(await loadPly(ev.target.result)); document.getElementById('loading').style.display = 'none'; }
        catch(err) { alert(err); document.getElementById('loading').style.display = 'none'; }
    };
    r.readAsArrayBuffer(f);
}

// Load from URL (Demo)
async function loadModelFromUrl(url) {
    if(!url) return;
    const loadingEl = document.getElementById('loading');
    const statusEl = document.getElementById('status');
    const progressFill = document.getElementById('progress');
    
    loadingEl.style.display = 'block';
    statusEl.innerText = "Downloading...";
    progressFill.style.width = '0%'; 

    try {
        const response = await fetch(url);
        if(!response.ok) throw "Network Error: " + response.status + " " + response.statusText;

        const contentLength = response.headers.get('content-length');
        const total = contentLength ? parseInt(contentLength, 10) : 0;
        let loaded = 0;

        const reader = response.body.getReader();
        const chunks = []; 

        while(true) {
            const {done, value} = await reader.read();
            if (done) break; 
            
            chunks.push(value);
            loaded += value.length;

            if (total > 0) {
                const percent = (loaded / total) * 100;
                progressFill.style.width = percent + "%";
                statusEl.innerText = `Downloading ${Math.round(percent)}%`; 
            } else {
                statusEl.innerText = `Downloaded ${(loaded/1024/1024).toFixed(2)} MB`;
            }
        }

        const combined = new Uint8Array(loaded);
        let offset = 0;
        for(const chunk of chunks) {
            combined.set(chunk, offset);
            offset += chunk.length;
        }
        
        statusEl.innerText = "Parsing...";
        await new Promise(r => setTimeout(r, 10)); 

        uploadData(await loadPly(combined.buffer));
        
        loadingEl.style.display = 'none';
        statusEl.innerText = "Loaded";
        statusEl.style.color = "#4fc3f7";

    } catch(e) {
        console.error(e);
        alert("Failed to load model: " + e);
        statusEl.innerText = "Failed... Drop/Select to replace";
        loadingEl.style.display = 'none';
    }
}

let shDegree = 0;
function setSHDegree(d) {
    shDegree = d;
    [0,1,2,3].forEach(i => {
        document.getElementById(`btn-sh${i}`).className = (i === d) ? 'active' : '';
    });
}

function updateCamParams(key, value) {
    camConfig[key] = parseFloat(value);
    document.getElementById(`val-${key}`).innerText = camConfig[key];
}

const Quat = {
    identity: () => [0, 0, 0, 1],
    setAxisAngle: (axis, rad) => {
        rad = rad * 0.5;
        const s = Math.sin(rad);
        return [axis[0]*s, axis[1]*s, axis[2]*s, Math.cos(rad)];
    },
    multiply: (a, b) => {
        const ax = a[0], ay = a[1], az = a[2], aw = a[3];
        const bx = b[0], by = b[1], bz = b[2], bw = b[3];
        return [
            ax*bw + aw*bx + ay*bz - az*by,
            ay*bw + aw*by + az*bx - ax*bz,
            az*bw + aw*bz + ax*by - ay*bx,
            aw*bw - ax*bx - ay*by - az*bz
        ];
    },
    toMat4: (q) => {
        const x = q[0], y = q[1], z = q[2], w = q[3];
        const x2 = x + x, y2 = y + y, z2 = z + z;
        const xx = x * x2, xy = x * y2, xz = x * z2;
        const yy = y * y2, yz = y * z2, zz = z * z2;
        const wx = w * x2, wy = w * y2, wz = w * z2;
        return [
            1-(yy+zz), xy+wz, xz-wy, 0,
            xy-wz, 1-(xx+zz), yz+wx, 0,
            xz+wy, yz-wx, 1-(xx+yy), 0,
             0, 0, 0, 1
        ];
    }
};

const camera = {
    quat: Quat.identity(),
    radius: 5,
    target: [0, 0, 0],
    dragging: false, lastX: 0, lastY: 0, button: -1,
    // MODIFIED: Touch State
    lastTouchDist: 0, lastTouchX: 0, lastTouchY: 0
};

// Mouse Events (PC)
canvas.addEventListener('mousedown', e => {
    camera.dragging = true;
    camera.button = e.button;
    camera.lastX = e.clientX;
    camera.lastY = e.clientY;
    if(e.button === 1) e.preventDefault();
});
window.addEventListener('mouseup', () => { camera.dragging = false; camera.button = -1; });
canvas.addEventListener('contextmenu', e => e.preventDefault());

canvas.addEventListener('mousemove', e => {
    if(!camera.dragging) return;
    const dx = e.clientX - camera.lastX;
    const dy = e.clientY - camera.lastY;
    camera.lastX = e.clientX;
    camera.lastY = e.clientY;
    
    if (camera.button === 0) { 
        const rotateSpeed = 0.005;
        const qYaw = Quat.setAxisAngle([0, 1, 0], -dx * rotateSpeed);
        camera.quat = Quat.multiply(camera.quat, qYaw);
        const qPitch = Quat.setAxisAngle([1, 0, 0], -dy * rotateSpeed);
        camera.quat = Quat.multiply(camera.quat, qPitch);
        const len = Math.sqrt(camera.quat[0]**2 + camera.quat[1]**2 + camera.quat[2]**2 + camera.quat[3]**2);
        camera.quat[0]/=len; camera.quat[1]/=len; camera.quat[2]/=len; camera.quat[3]/=len;
    } 
    else if (camera.button === 1) { 
        const panSpeed = camera.radius * 0.001;
        const R = Quat.toMat4(camera.quat);
        const right = [R[0], R[1], R[2]];
        const up = [R[4], R[5], R[6]];
        camera.target[0] += right[0] * (-dx * panSpeed) + up[0] * (dy * panSpeed);
        camera.target[1] += right[1] * (-dx * panSpeed) + up[1] * (dy * panSpeed);
        camera.target[2] += right[2] * (-dx * panSpeed) + up[2] * (dy * panSpeed);
    }
});
canvas.addEventListener('wheel', e => {
    e.preventDefault();
    camera.radius *= (1 + e.deltaY * 0.001);
    camera.radius = Math.max(0.1, camera.radius);
}, {passive:false});

// MODIFIED: Touch Events (Mobile)
// 1 Finger = Rotate, 2 Fingers = Zoom/Pan
canvas.addEventListener('touchstart', e => {
    if (e.touches.length === 1) {
        camera.dragging = true;
        camera.lastX = e.touches[0].clientX;
        camera.lastY = e.touches[0].clientY;
        camera.button = 0; // Simulate Left Click
    } else if (e.touches.length === 2) {
        camera.dragging = true;
        camera.button = 2; // Special Touch Mode
        
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        camera.lastTouchDist = Math.sqrt(dx*dx + dy*dy);
        
        camera.lastTouchX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
        camera.lastTouchY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
    }
}, {passive:false});

canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    if (!camera.dragging) return;

    if (e.touches.length === 1 && camera.button === 0) {
        const dx = e.touches[0].clientX - camera.lastX;
        const dy = e.touches[0].clientY - camera.lastY;
        camera.lastX = e.touches[0].clientX;
        camera.lastY = e.touches[0].clientY;

        const rotateSpeed = 0.005;
        const qYaw = Quat.setAxisAngle([0, 1, 0], -dx * rotateSpeed);
        camera.quat = Quat.multiply(camera.quat, qYaw);
        const qPitch = Quat.setAxisAngle([1, 0, 0], -dy * rotateSpeed);
        camera.quat = Quat.multiply(camera.quat, qPitch);
        const len = Math.sqrt(camera.quat[0]**2 + camera.quat[1]**2 + camera.quat[2]**2 + camera.quat[3]**2);
        camera.quat[0]/=len; camera.quat[1]/=len; camera.quat[2]/=len; camera.quat[3]/=len;
    } 
    else if (e.touches.length === 2 && camera.button === 2) {
        const t1 = e.touches[0];
        const t2 = e.touches[1];
        
        // 1. Zoom (Pinch)
        const dx = t1.clientX - t2.clientX;
        const dy = t1.clientY - t2.clientY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const deltaDist = dist - camera.lastTouchDist;
        
        camera.radius *= (1 - deltaDist * 0.005);
        camera.radius = Math.max(0.1, camera.radius);
        camera.lastTouchDist = dist;

        // 2. Pan (Two Finger Drag)
        const cx = (t1.clientX + t2.clientX) / 2;
        const cy = (t1.clientY + t2.clientY) / 2;
        const panDx = cx - camera.lastTouchX;
        const panDy = cy - camera.lastTouchY;
        
        camera.lastTouchX = cx;
        camera.lastTouchY = cy;

        const panSpeed = camera.radius * 0.001;
        const R = Quat.toMat4(camera.quat);
        const right = [R[0], R[1], R[2]];
        const up = [R[4], R[5], R[6]];
        camera.target[0] += right[0] * (-panDx * panSpeed) + up[0] * (panDy * panSpeed);
        camera.target[1] += right[1] * (-panDx * panSpeed) + up[1] * (panDy * panSpeed);
        camera.target[2] += right[2] * (-panDx * panSpeed) + up[2] * (panDy * panSpeed);
    }
}, {passive:false});

canvas.addEventListener('touchend', () => {
    camera.dragging = false;
});


document.addEventListener('dragover', e => e.preventDefault());
document.addEventListener('drop', e => {
    e.preventDefault();
    const f = e.dataTransfer.files[0];
    if(!f) return;
    document.getElementById('loading').style.display = 'block';
    document.getElementById('status').innerText = "Loading dropped file...";
    const r = new FileReader();
    r.onload = async(ev) => {
        try { uploadData(await loadPly(ev.target.result)); document.getElementById('loading').style.display = 'none'; }
        catch(err) { alert(err); document.getElementById('loading').style.display = 'none'; }
    };
    r.readAsArrayBuffer(f);
});

// ====================================================================================
// Rendering Loop
// ====================================================================================

// Render Mode Management
let renderMode = 0; // 0=All, 1=Surfel Only, 2=GS Only
function setRenderMode(m) {
    renderMode = m;
    ['btn-all','btn-surfel','btn-gs'].forEach((id, i) => {
        document.getElementById(id).className = (i === m) ? 'active' : '';
    });
}

function getProjMatrix(fov, aspect, near, far) {
    const f = 1.0 / Math.tan(fov / 2);
    const nf = 1 / (near - far);
    return [ f/aspect,0,0,0, 0,f,0,0, 0,0,(far+near)*nf,-1, 0,0,(2*far*near)*nf,0 ];
}

function render() {
    requestAnimationFrame(render);
    const w = canvas.width; const h = canvas.height;
    
    const R = Quat.toMat4(camera.quat);
    const eyeX = camera.target[0] + R[8]*camera.radius;
    const eyeY = camera.target[1] + R[9]*camera.radius;
    const eyeZ = camera.target[2] + R[10]*camera.radius;
    const view = [
        R[0], R[4], R[8], 0,
        R[1], R[5], R[9], 0,
        R[2], R[6], R[10], 0,
        -(R[0]*eyeX+R[1]*eyeY+R[2]*eyeZ), -(R[4]*eyeX+R[5]*eyeY+R[6]*eyeZ), -(R[8]*eyeX+R[9]*eyeY+R[10]*eyeZ), 1
    ];
    
    const camPos = [eyeX, eyeY, eyeZ];
    const fovRad = camConfig.fov * Math.PI / 180.0;
    const proj = getProjMatrix(fovRad, w/h, camConfig.near, camConfig.far);

    surfel_fbo.bind();
    gl.clearColor(0,0,0,0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    let curScFrameBuffer = surfel_fbo;
    let isRenderSth = false;

    // 1. Draw Surfels (Depth Write ON)
    if (countSurfel > 0 && renderMode !== 2) {
        gl.useProgram(progSurfel);
        gl.uniformMatrix4fv(gl.getUniformLocation(progSurfel, "viewMat"), false, new Float32Array(view));
        gl.uniformMatrix4fv(gl.getUniformLocation(progSurfel, "projMat"), false, new Float32Array(proj));
        
        if (texSHSurfel) {
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texSHSurfel);
            gl.uniform1i(gl.getUniformLocation(progSurfel, "texSH"), 0);
            gl.uniform2f(gl.getUniformLocation(progSurfel, "texSHDim"), texSHSurfelDim[0], texSHSurfelDim[1]);
        }
        gl.uniform1i(gl.getUniformLocation(progSurfel, "shDegree"), shDegree);
        gl.uniform3fv(gl.getUniformLocation(progSurfel, "camPos"), new Float32Array(camPos));

        gl.enable(gl.DEPTH_TEST);
        gl.depthMask(true);
        gl.disable(gl.BLEND);
        gl.bindVertexArray(vaoSurfel);
        gl.drawArraysInstanced(gl.TRIANGLE_STRIP, 0, 4, countSurfel);

        // mod depth
        accum_fbo.bind();
        gl.clearColor(0,0,0,0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.useProgram(progDepthMod);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, surfel_fbo.texture);
        gl.uniform1i(gl.getUniformLocation(progDepthMod, "texColor"), 0);
        gl.uniform2f(gl.getUniformLocation(progDepthMod, "zNearFar"), camConfig.near, camConfig.far);
        gl.bindVertexArray(vaoQuad);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        curScFrameBuffer = accum_fbo;

        isRenderSth = true;
    }

    // 2. Draw Gaussians (Depth Write OFF, Blend Additive)
    if (countGaussian > 0 && renderMode !== 1) {
        gl.useProgram(progGaussian);
        gl.uniformMatrix4fv(gl.getUniformLocation(progGaussian, "viewMat"), false, new Float32Array(view));
        gl.uniformMatrix4fv(gl.getUniformLocation(progGaussian, "projMat"), false, new Float32Array(proj));
        gl.uniform4f(gl.getUniformLocation(progGaussian, "viewport"), 0, 0, w, h);
        
        const f = 1.0 / Math.tan(fovRad / 2.0);
        gl.uniform4f(gl.getUniformLocation(progGaussian, "projParams"), h * f, camConfig.near, camConfig.far, 0); 
        
        if (texSHGaussian) {
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texSHGaussian);
            gl.uniform1i(gl.getUniformLocation(progGaussian, "texSH"), 0);
            gl.uniform2f(gl.getUniformLocation(progGaussian, "texSHDim"), texSHGaussianDim[0], texSHGaussianDim[1]);
        }
        gl.uniform1i(gl.getUniformLocation(progGaussian, "shDegree"), shDegree);
        gl.uniform3fv(gl.getUniformLocation(progGaussian, "camPos"), new Float32Array(camPos));

        gl.enable(gl.DEPTH_TEST);
        gl.depthMask(false);
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.ONE, gl.ONE);
        gl.bindVertexArray(vaoGaussian);
        gl.drawArraysInstanced(gl.TRIANGLE_STRIP, 0, 4, countGaussian);

        isRenderSth = true;
    }

    // --- Pass 3: Normalize to Screen ---
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0, 0, w, h);
    gl.clearColor(0.1, 0.1, 0.1, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    if (isRenderSth && curScFrameBuffer) {
        gl.useProgram(progNormalize);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, curScFrameBuffer.texture);
        gl.uniform1i(gl.getUniformLocation(progNormalize, "texColor"), 0);
        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.BLEND);

        gl.bindVertexArray(vaoQuad);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        gl.bindVertexArray(null);
        gl.depthMask(true);
    }
}

// MODIFIED: Init call to check mobile status
checkMobile();
render();
</script>
</body>
</html>